/**
 * 오버로딩 vs 오버라이딩 두 개념의 주요 차이점은 다음과 같습니다
 *
 * 오버로딩 (Overloading, 여러 개의 로딩)
 * - 같은 이름의 메서드를 여러 개 정의하는 것입니다.
 * - 메서드 이름은 같지만 매개변수의 개수나 타입이 다릅니다.
 * - 하나의 클래스 내에서 발생합니다.
 * - 새로운 메서드를 추가하는 개념입니다.
 *
 * 오버라이딩 (Overriding, 재정의)
 * - 상위 클래스의 메서드를 하위 클래스에서 재정의하는 것입니다.
 * - 메서드 이름, 매개변수, 반환 타입이 모두 동일해야 합니다.
 * - 상속 관계에 있는 클래스 간에 발생합니다.
 * - 기존 메서드의 내용을 변경하는 개념입니다.
 *
 * 주요 차이점
 * 목적: 오버로딩은 같은 기능을 하는 메서드를 하나의 이름으로 사용하기 위함이고,
 * 오버라이딩은 상속받은 메서드의 기능을 변경하기 위함입니다.
 * 매개변수: 오버로딩은 매개변수의 개수나 타입이 달라야 하지만,
 *     오버라이딩은 매개변수가 완전히 동일해야 합니다.
 * 반환 타입: 오버로딩은 반환 타입이 달라도 되지만,
 *     오버라이딩은 반환 타입이 동일해야 합니다.
 * 적용 범위: 오버로딩은 한 클래스 내에서 발생하고,
 *     오버라이딩은 상속 관계에 있는 클래스 간에 발생합니다.
 * 접근 제어자: 오버라이딩 시 접근 제어자는
 *     부모 클래스의 메서드보다 더 좁은 범위로 변경할 수 없습니다.
 *
 * 이 두 개념을 적절히 활용하면 코드의 재사용성과 유연성을 높일 수 있으며,
 *     객체 지향 프로그래밍의 핵심 원칙인 다형성을 효과적으로 구현할 수 있습니다.
 */

/**
 * 파라미터를
 * 1. 하나를 받거나
 * 2. 세개를 받는 함수.
 *
 * 만약 3개의 파라미터를 받는다면
 * 각각의 아이돌을 각각의 파라미터로 받아서
 * 그 아이돌들의 이름을 출력하는 함수.
 * 주의!: 오버로딩은 구현 된 함수에만 적용할 수 있다.
 * - 최대 3개의 파라미터를 받는 (구현체) 함수가 있다면,
 *     최대 3개의 파라미터 오버로딩까지만 가능하다.
 * - 오버로딩은 유지보수 시에 헤깔릴 수 있으므로 실무에서 사용을 권장하지 않는다.
 *     이런 개념이 있다는 것 정도만 알고 있으면 된다.
 */
function stringOrStrings(members: string): string;
function stringOrStrings(
  member1: string,
  member2: string,
  member3: string
): string;

function stringOrStrings(
  memberOrMembers: string,
  member2?: string,
  member3?: string
) {
  if (member2 && member3) {
    return `${memberOrMembers}, ${member2}, ${member3}`;
  } else {
    return memberOrMembers;
  }
}

console.log(stringOrStrings("member1, member2"));
console.log(stringOrStrings("member1", "member2", "member3"));
// 오버로딩된 함수의 형태와 다르기 때문에 에러가 발생합니다.
// console.log(stringOrStrings("member1", "member2")); // error!
